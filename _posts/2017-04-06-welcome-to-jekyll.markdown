---
layout: post
title:  "Слияние двух отсортированных массивов"
date:   2017-04-06 18:15:20 +0300
categories: jekyll update
---
Недавно я натолкнулся на интересную задачу, которую решил на языке программирования Pascal. Эта задача о том, как склеить два отсортированных массива в третий, который должен быть тоже отсортированным. Ниже приводится условие данной задачи и разбор решения.

## Условие задачи:

Даны целочисленные массивы А[1..10] и B[1..10], причем А [1] ≤ А [2] ≤ ... ≤ А [10], В [1] ≤ В [2] ≤ ... ≤ В [10] Постройте массив C[1..20], содержащий все элементы массивов А и В, в котором С [1] ≤ С [2] ≤ ... ≤ С [20].

*Пример ввода:*

1 3 5 7 8 9 11 13 15 17 2 4 6 8 10 12 14 16 18 20

*Пример вывода:*

1
2
3
4
5
6
7
8
8
9
10
11
12
13
14
15
16
17
18
20

## Интерпретация условия задачи:

У нас есть два отсортированных по возрастанию массива А и В. Нужно получить отсортированный по возрастанию массив С из массивов А и В.

## Идея  решения:

Представим оба массива A и B, как ленточные конвейеры, находящиеся на одном уровне и передвигающиеся числа справа налево. А на уровне ниже находится третий конвейер C, на который будут падать числа. За один ход мы передвигаем конвейер C влево для, того чтобы словить одно падающее число. В это же время сверху передвигается один из конвейеров A или B. За каждый такой ход необходимо, чтобы всегда сверху падало минимальное из оставшихся чисел конвейеров A или B. Если случится так, что на обоих конвейерах A и B слева находится одинаковое число, то не имеет значения какой из конвейеров передвигать, чтобы число упало. Если же на каком-то из конвейеров чисел не осталось, то передвигаем только тот конвейер, на котором остались числа. Всего таких ходов будет 20 - столько же, сколько нужно заполнить числами в массиве C. Таким образом, мы гарантируем что на конвейере C получится массив чисел отсортирован в порядке возрастания.

![Контейнеры](/assets/images/cnt.gif)

## Моё решение:

Массив А, В и С;
Указатели X, Y и I;
Х - указатель на то, какой элемент еще не упал с конвейера и может упасть на следующем шаге, если он окажется меньшим из массива А.
Y - указатель на то, какой элемент еще не упал с конвейера и может упасть на следующем шаге, если он окажется меньшим из массива В.
I - указывает на то, который элемент мы заполняем на текущем шаге.

*A: 1 3 5 7 8 9 11 13 15 17

X: ^ 

X=1

B: 2 4 6 8 10 12 14 16 18 20

Y: ^

Y=1*

Массив С пустой сначала;

*С: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
I: ^
I=1*

Первоначально x, y имеют значение = 1, и указывают на первый элемент массива.
На первом шаге берется  первый элемент массива А[1]=1 и  первый элемент массива В[1]=2,из них выбираем наименьший - это 1, ложим его в массив C в то место, куда указывает переменная i на первом шаге, это будет первый элемент… Таким образом, после первого шага в массиве C будет находится один элемент C[1] = 1.


{% highlight ruby %}
def print_hi(name)
  puts "Hi, #{name}"
end
print_hi('Tom')
#=> prints 'Hi, Tom' to STDOUT.
{% endhighlight %}

Check out the [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
